"""
Speculative execution vulnerability detection.
Provides components for detecting sensitive data leakage in speculative execution.
"""
import sys
import os

# Setup paths to use local angr
from angrspectre.config import setup_paths
setup_paths()

import angr
import claripy
import collections

from angrspectre.core.memory_bounds import BoundaryAccessStrategy, MemoryBoundsTracker, can_access_out_of_bounds, check_concretization_success, log_concretization
from angrspectre.core.secret_tracking import create_sensitive_symbol, contains_secret_data
from angrspectre.utils.utils import isAst, describeAst, isDefinitelyEqual
from angrspectre.core.memory_model import MemoryValue, StructuredPointer, GenericPublicPointer

import logging
l = logging.getLogger(name=__name__)

def setup_oob_detection(proj, state):
    """Configure state for out-of-bounds access detection"""
    state.register_plugin('bounds_tracker', MemoryBoundsTracker(proj))
    state.register_plugin('spectre', OutOfBoundsTracker())
    state.spectre.arm(state)
    assert state.spectre.armed()

def setup_secret_detection(proj, state, whitelist=None, trace=False, takepath=[]):
    """Configure state for secret data access detection"""
    args = state.globals['args']
    otherSecrets = state.globals['otherSecrets'] if 'otherSecrets' in state.globals else []
    state.register_plugin('spectre',
        SecretAccessTracker(
            vars=args.values(),
            secretIntervals=otherSecrets,
            whitelist=whitelist,
            trace=trace,
            takepath=takepath))
    state.spectre.arm(state)
    assert state.spectre.armed()

class OutOfBoundsTracker(angr.SimStatePlugin):
    """
    Tracks memory accesses that may leak data through out-of-bounds access.
    Treats uninitialized memory as sensitive and detects when it's accessed.
    """
    def __init__(self, armed=False):
        super().__init__()
        self._armed = armed
        self.violation = None

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        return OutOfBoundsTracker(armed=self._armed)

    def arm(self, state):
        """Set up hooks for vulnerability detection"""
        # Register detection callbacks
        state.inspect.b('mem_read',  when=angr.BP_AFTER, condition=_is_tainted_read, action=detect_unsafe_read)
        state.inspect.b('mem_write', when=angr.BP_AFTER, condition=_is_tainted_write, action=detect_unsafe_write)
        state.inspect.b('exit', when=angr.BP_BEFORE, condition=_is_tainted_branch, action=detect_unsafe_branch)

        # Set up strategies for address concretization
        state.memory.read_strategies.insert(0, BoundaryAccessStrategy())
        state.memory.write_strategies.insert(0, BoundaryAccessStrategy())
        state.inspect.b('address_concretization', when=angr.BP_AFTER, 
                        condition=check_concretization_success, action=log_concretization)

        # Configure state options
        state.options.add(angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY)
        state.options.add(angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS)
        state.options.add(angr.options.SYMBOLIC_INITIAL_VALUES)
        state.options.add(angr.options.SPECIAL_MEMORY_FILL)
        state._special_memory_filler = create_sensitive_memory
        state.options.add(angr.options.SYMBOLIC_WRITE_ADDRESSES)

        self._armed = True

    def armed(self):
        """Check if detection is enabled"""
        return self._armed

def create_sensitive_memory(name, bits, state):
    """Create a sensitive symbol for uninitialized memory"""
    return create_sensitive_symbol(state, name, bits)

class SecretAccessTracker(angr.SimStatePlugin):
    """
    Tracks access to designated secret memory regions.
    Detects when secret data affects memory accesses or control flow.
    """
    _counter = 0

    def __init__(self, vars=[], secretIntervals=[], whitelist=None, armed=False, trace=False, takepath=[]):
        """
        Initialize with:
        - vars: Pairs of (variable, MemoryValue) specifying secret data locations
        - secretIntervals: Ranges of memory marked as secret
        - whitelist: Instruction addresses to ignore
        - trace: Enable verbose tracing
        - takepath: Path constraints to follow
        """
        super().__init__()
        self.vars = vars
        self._armed = armed
        self._trace = trace
        self.secretIntervals = secretIntervals
        self.whitelist = whitelist if whitelist else []
        self.takepath = collections.deque(takepath)
        self.violation = None
        self.uid = self._get_unique_id()
        self.vex = None

    @classmethod
    def _get_unique_id(cls):
        cls._counter += 1
        return cls._counter

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        copied = SecretAccessTracker(
            vars=self.vars,
            secretIntervals=self.secretIntervals,
            whitelist=self.whitelist,
            armed=self._armed,
            trace=self._trace,
            takepath=self.takepath)
        copied.vex = self.vex
        if self._trace:
            l.info(f"new state state{copied.uid} copied from state{self.uid}")
        return copied

    def arm(self, state, trace=False):
        """Configure state for secret data detection"""
        if self._armed:
            l.warn("called arm() on already-armed SecretAccessTracker")
            return

        # Set up debugging hooks if tracing is enabled
        if self._trace:
            state.inspect.b('mem_read', when=angr.BP_AFTER, action=dbg_mem_read)
            state.inspect.b('reg_read', when=angr.BP_AFTER, action=dbg_reg_read)
            state.inspect.b('tmp_read', when=angr.BP_AFTER, action=dbg_tmp_read)
            state.inspect.b('mem_write', when=angr.BP_AFTER, action=dbg_mem_write)
            state.inspect.b('reg_write', when=angr.BP_AFTER, action=dbg_reg_write)
            state.inspect.b('tmp_write', when=angr.BP_AFTER, action=dbg_tmp_write)
            state.inspect.b('instruction', when=angr.BP_BEFORE, action=dbg_instr)
            state.inspect.b('statement', when=angr.BP_BEFORE, action=dbg_stmt)
            state.inspect.b('irsb', when=angr.BP_BEFORE, action=dbg_irsb)
            
        # Safety check for null pointers
        state.inspect.b('instruction', when=angr.BP_BEFORE, 
                      condition=lambda state: state.inspect.instruction < 4096, 
                      action=segfault)

        # Register detection callbacks
        state.inspect.b('mem_read',  when=angr.BP_AFTER, condition=_is_tainted_read, action=detect_unsafe_read)
        state.inspect.b('mem_write', when=angr.BP_AFTER, condition=_is_tainted_write, action=detect_unsafe_write)
        state.inspect.b('exit', when=angr.BP_BEFORE, condition=_is_tainted_branch, action=detect_unsafe_branch)

        # Configure state options
        state.options.add(angr.options.SYMBOLIC_WRITE_ADDRESSES)
        state.options.add(angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY)
        state.options.add(angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS)
        state.options.add(angr.options.SYMBOLIC_INITIAL_VALUES)

        # Initialize memory layout
        secretStart = 0x1100000  # Address space for secret data
        secretMustEnd = 0x2000000  # Upper bound for secret data

        notSecretAddresses = []  # Addresses that can't point to secrets
        
        # Process variables and memory regions
        for (var, val) in self.vars:
            assert isAst(var)
            assert isinstance(val, MemoryValue)
            
            if val.value is not None:
                state.add_constraints(var == val.value)
                
            if val.sensitive:
                pass  # Secret scalar values handled elsewhere
            elif isinstance(val, StructuredPointer):
                if val.safe_pointer:
                    notSecretAddresses.append(var)
                    
                (memmap, newStart) = build_memory_layout(var, val.pointee, secretStart, secretMustEnd)
                secretStart = newStart
                self.secretIntervals.extend(memmap.secretIntervals)
                notSecretAddresses.extend(memmap.notSecretAddresses)
                
                # Initialize memory with concrete values
                for (a, (v, bits)) in memmap.concreteAssignments.items():
                    if bits == 8: state.mem[a].uint8_t = v
                    elif bits == 16: state.mem[a].uint16_t = v
                    elif bits == 32: state.mem[a].uint32_t = v
                    elif bits == 64: state.mem[a].uint64_t = v
                    else: raise ValueError(f"unexpected bitlength: {bits}")
                    
            elif isinstance(val, GenericPublicPointer):
                if val.safe_pointer:
                    notSecretAddresses.append(var)

        # Normalize and finalize secret memory regions
        self.secretIntervals = merge_memory_regions(self.secretIntervals)

        # Mark secret memory with sensitive symbols
        for (mn, mx) in self.secretIntervals:
            if isAst(mn):
                # Resolve symbolic addresses to concrete locations
                secretStart = state.solver.eval_one(mn, default=secretStart)
                if state.solver.solution(mn, secretStart):
                    mn_as_int = secretStart
                    state.solver.add(mn == mn_as_int)
                    length = state.solver.eval_one(mx-mn_as_int)
                    if length is None:
                        raise ValueError(f"No unique solution for interval length: {mx-mn_as_int}")
                    mx_as_int = mn_as_int + length
                    state.solver.add(mx == mx_as_int)
                    secretStart += length
                else:
                    raise ValueError(f"Can't resolve secret address {mn} to value 0x{secretStart:x}")
            elif isAst(mx):
                raise ValueError(f"Unsupported: concrete min with symbolic max: {mn}, {mx}")
            else:
                mn_as_int = mn
                mx_as_int = mx
                
            # Mark each byte in range as secret
            for i in range(mn_as_int, mx_as_int):
                state.mem[i].uint8_t = create_sensitive_memory("secret", 8, state)

        # Ensure safe pointers cannot access secret data
        for addr in notSecretAddresses:
            state.solver.add(claripy.And(*[claripy.Or(addr < mn, addr >= mx) 
                                          for (mn, mx) in self.secretIntervals]))

        # Add concretization strategies
        state.memory.read_strategies.insert(0, SecretSearchStrategy(self.secretIntervals))
        state.memory.write_strategies.insert(0, SecretSearchStrategy(self.secretIntervals))

        self._armed = True

    def armed(self):
        """Check if detection is enabled"""
        return self._armed

class MemoryMap:
    """Maps memory contents for vulnerability detection"""
    def __init__(self):
        self.secretIntervals = []     # Ranges of secret memory: [(start, end), ...]
        self.concreteAssignments = {} # {address: (value, bit_width)}
        self.notSecretAddresses = []  # Addresses that cannot point to secrets

    def add_secret_region(self, start, end):
        """Mark memory range as containing secrets"""
        self.secretIntervals.append((start, end))

    def assign(self, addr, val, bits):
        """Store a value at address"""
        self.concreteAssignments[addr] = (val, bits)

    def add_safe_address(self, addr):
        """Mark address as unable to access secrets"""
        self.notSecretAddresses.append(addr)

    def merge_with(self, other_map):
        """Combine with another memory map"""
        self.secretIntervals.extend(other_map.secretIntervals)
        self.concreteAssignments.update(other_map.concreteAssignments)
        self.notSecretAddresses.extend(other_map.notSecretAddresses)

def build_memory_layout(var, pointee, scratch_start, scratch_end):
    """
    Build a memory layout for the given pointer and pointee
    
    Args:
        var: Address (concrete or symbolic)
        pointee: Memory value or list of memory values
        scratch_start: Start of available memory region
        scratch_end: End of available memory region
        
    Returns:
        Tuple of (MemoryMap, new_scratch_start)
    """
    memmap = MemoryMap()
    
    if isinstance(pointee, MemoryValue):
        pointee = [pointee]  # Convert single value to list
        
    if isinstance(pointee, list):
        # Process array or struct elements
        if all(v.sensitive for v in pointee):
            # All elements are secret - mark entire region
            total_size = sum(v.bits for v in pointee) // 8
            memmap.add_secret_region(var, var + total_size)
        else:
            # Process each element individually
            bytes_so_far = 0
            for v in pointee:
                elem_addr = var + bytes_so_far
                
                if v.sensitive:
                    # Mark just this element as secret
                    memmap.add_secret_region(elem_addr, elem_addr + (v.bits // 8))
                elif isinstance(v, StructuredPointer):
                    # Handle nested pointer
                    v_addr = v.value if v.value is not None else scratch_start
                    memmap.assign(elem_addr, v_addr, v.bits)
                    scratch_start += v.max_size
                    
                    if v.safe_pointer:
                        memmap.add_safe_address(v_addr)
                        
                    # Process what the pointer points to
                    pointee_map, new_scratch = build_memory_layout(v_addr, v.pointee, scratch_start, scratch_end)
                    scratch_start = new_scratch
                    memmap.merge_with(pointee_map)
                    
                elif isinstance(v, GenericPublicPointer):
                    if v.safe_pointer or v.value is not None:
                        v_addr = v.value if v.value is not None else scratch_start
                        memmap.assign(elem_addr, v_addr, v.bits)
                        scratch_start += v.max_size
                        
                        if v.safe_pointer:
                            memmap.add_safe_address(v_addr)
                else:
                    # Regular public value
                    if v.value is not None:
                        memmap.assign(elem_addr, v.value, v.bits)
                        
                bytes_so_far += v.bits // 8
    else:
        raise ValueError(f"Unsupported pointee type: {pointee}")
        
    return memmap, scratch_start

def merge_memory_regions(intervals):
    """
    Merge overlapping memory regions and sort them
    
    Args:
        intervals: List of (start, end) memory ranges
        
    Returns:
        Consolidated list of non-overlapping regions
    """
    assert isinstance(intervals, list)
    
    # Sort intervals based on symbolic or concrete addresses
    def interval_key(pair):
        if isAst(pair[0]) and isAst(pair[1]):
            lower = pair[0]
            if lower.op == '__add__':
                try:
                    bvs = next(arg.args[0] for arg in lower.args if arg.op == 'BVS')
                    bvv = next(arg.args[0] for arg in lower.args if arg.op == 'BVV')
                    return (bvs, bvv)
                except StopIteration:
                    pass
            elif lower.op == 'BVS':
                return (lower.args[0], 0)
        elif not isAst(pair[0]):
            return ('\xff', pair[0])
        return ('', -1)
    
    # Sort and merge
    intervals.sort(key=interval_key)
    merged_intervals = []
    
    while intervals:
        interval = intervals.pop()
        if intervals:
            prev_interval = intervals[-1]
            # Merge contiguous intervals
            while isDefinitelyEqual(prev_interval[1], interval[0]):
                intervals.pop()
                interval = (prev_interval[0], interval[1])
                if not intervals:
                    break
                prev_interval = intervals[-1]
        merged_intervals.insert(0, interval)
        
    return merged_intervals

# Debug callback functions
def dbg_mem_read(state):
    addr = state.inspect.mem_read_address
    expr = state.inspect.mem_read_expr
    l.info(f"state{state.spectre.uid}: read {describeAst(expr)} from addr {describeAst(addr)}")

def dbg_reg_read(state):
    offset = state.inspect.reg_read_offset
    expr = state.inspect.reg_read_expr
    l.info(f"state{state.spectre.uid}: read {describeAst(expr)} from offset {offset}")

def dbg_tmp_read(state):
    num = state.inspect.tmp_read_num
    expr = state.inspect.tmp_read_expr
    l.info(f"state{state.spectre.uid}: read {describeAst(expr)} from tmp {num}")

def dbg_mem_write(state):
    addr = state.inspect.mem_write_address
    expr = state.inspect.mem_write_expr
    l.info(f"state{state.spectre.uid}: wrote {describeAst(expr)} to addr {describeAst(addr)}")

def dbg_reg_write(state):
    offset = state.inspect.reg_write_offset
    expr = state.inspect.reg_write_expr
    l.info(f"state{state.spectre.uid}: wrote {describeAst(expr)} to offset {offset}")

def dbg_tmp_write(state):
    num = state.inspect.tmp_write_num
    expr = state.inspect.tmp_write_expr
    l.info(f"state{state.spectre.uid}: wrote {describeAst(expr)} to tmp {num}")

def segfault(state):
    l.info(f'state{state.spectre.uid}: SEGMENTATION FAULT (addr {state.inspect.instruction})')
    state.solver.add(1 == 0)

def dbg_instr(state):
    block = state.block()
    n = block.instruction_addrs.index(state.inspect.instruction)
    l.info(f'state{state.spectre.uid}: \033[0m{block.capstone.insns[n]}')

def dbg_stmt(state):
    stms = state.spectre.vex.statements
    l.info(f'state{state.spectre.uid}: \033[0m{stms[state.inspect.statement]}')

def dbg_irsb(state):
    state.spectre.vex = state.block().vex

# Detection condition functions
def _is_tainted_read(state):
    addr = state.inspect.mem_read_address
    return isAst(addr) and contains_secret_data(addr)

def _is_tainted_write(state):
    addr = state.inspect.mem_write_address
    return isAst(addr) and contains_secret_data(addr)

def _is_tainted_branch(state):
    guard = state.inspect.exit_guard
    return (isAst(guard) and contains_secret_data(guard) and
            state.solver.satisfiable(extra_constraints=[guard == True]) and
            state.solver.satisfiable(extra_constraints=[guard == False]))

def _can_access_secrets(state, ast):
    """Check if an address can point to secret memory"""
    if not isinstance(state.spectre, SecretAccessTracker):
        return False
        
    # Test if address can be in any secret interval
    constraints = [claripy.And(ast >= mn, ast < mx) for (mn, mx) in state.spectre.secretIntervals]
    return state.solver.satisfiable(extra_constraints=[claripy.Or(*constraints)])

# Detection handlers
def detect_unsafe_read(state):
    """Handle detection of a read with a tainted address"""
    if isinstance(state.spectre, SecretAccessTracker) and state.addr in state.spectre.whitelist:
        l.info(f"Whitelisted unsafe read at {hex(state.addr)}, address {describeAst(state.inspect.mem_read_address)}")
        return
        
    path = ''.join(state.spec.path) if state.has_plugin('spec') else 'not available'
    l.error(f"\n!!!!!!!! UNSAFE READ !!!!!!!!\n"
            f"  Instruction Address {hex(state.addr)}\n"
            f"  Read Address {describeAst(state.inspect.mem_read_address)}\n"
            f"  Read Value {describeAst(state.inspect.mem_read_expr)}\n"
            f"  Path {path}\n"
            f"  Arguments: {{{', '.join(f'{name}: {state.solver.eval(bvs)}' for name, (bvs, _) in state.globals['args'].items())}}}\n"
            f"  Constraints: {state.solver.constraints}\n")
            
    state.spectre.violation = ('read', state.addr, state.inspect.mem_read_address, state.inspect.mem_read_expr)

def detect_unsafe_write(state):
    """Handle detection of a write with a tainted address"""
    if isinstance(state.spectre, SecretAccessTracker) and state.addr in state.spectre.whitelist:
        l.info(f"Whitelisted unsafe write at {hex(state.addr)}, address {describeAst(state.inspect.mem_write_address)}")
        return
        
    path = ''.join(state.spec.path) if state.has_plugin('spec') else 'not available'
    l.error(f"\n!!!!!!!! UNSAFE WRITE !!!!!!!!\n"
            f"  Instruction Address {hex(state.addr)}\n"
            f"  Write Address {describeAst(state.inspect.mem_write_address)}\n"
            f"  Write Value {describeAst(state.inspect.mem_write_expr)}\n"
            f"  Path {path}\n"
            f"  Arguments: {{{', '.join(f'{name}: {state.solver.eval(bvs)}' for name, (bvs, _) in state.globals['args'].items())}}}\n"
            f"  Constraints: {state.solver.constraints}\n")
            
    state.spectre.violation = ('write', state.addr, state.inspect.mem_write_address, state.inspect.mem_write_expr)

def detect_unsafe_branch(state):
    """Handle detection of a branch with a tainted condition"""
    if isinstance(state.spectre, SecretAccessTracker) and state.addr in state.spectre.whitelist:
        l.info(f"Whitelisted unsafe branch at {hex(state.addr)}, condition {describeAst(state.inspect.exit_guard)}")
        return
        
    path = ''.join(state.spec.path) if state.has_plugin('spec') else 'not available'
    l.error(f"\n!!!!!!!! UNSAFE BRANCH !!!!!!!!\n"
            f"  Instruction Address {hex(state.addr)}\n"
            f"  Branch Target {state.inspect.exit_target}\n"
            f"  Guard {describeAst(state.inspect.exit_guard)}\n"
            f"  Path {path}\n"
            f"  Arguments: {{{', '.join(f'{name}: {state.solver.eval(bvs)}' for name, (bvs, _) in state.globals['args'].items())}}}\n"
            f"  Constraints: {state.solver.constraints}\n")
            
    state.spectre.violation = ('branch', state.addr, state.inspect.exit_target, state.inspect.exit_guard)

class SecretSearchStrategy(angr.concretization_strategies.SimConcretizationStrategy):
    """
    Attempts to concretize addresses to point to secret data when possible.
    Helps find more potential vulnerabilities during analysis.
    """
    def __init__(self, target_intervals, **kwargs):
        super().__init__(**kwargs)
        self.target_intervals = target_intervals

    def concretize(self, memory, addr):
        """Try to make address point to secret memory if possible"""
        if not self.target_intervals:
            return None
            
        try:
            # Create constraint to make address point to a secret interval
            constraint = claripy.Or(*[claripy.And(addr >= mn, addr < mx) 
                                    for (mn, mx) in self.target_intervals])
            return [self._any(memory, addr, extra_constraints=[constraint])]
        except angr.errors.SimUnsatError:
            # No solution - can't make address point to secret
            return None

class VulnerabilityFilter(angr.exploration_techniques.ExplorationTechnique):
    """
    Separates states with detected vulnerabilities into a special stash.
    Makes it easy to identify and analyze vulnerable execution paths.
    """
    def __init__(self):
        super().__init__()

    def filter(self, simgr, state, **kwargs):
        if state.spectre.violation:
            return 'spectre_violation'
        return simgr.filter(state, **kwargs)